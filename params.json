{"name":"Wax","tagline":"Designed to aid in the reuse of Expression trees.","body":"Wax\r\n===\r\n\r\nWax grew out of my frustration with Linq-to-SQL's inability to\r\nhandle `InvocationExpression`s, so its main purpose is to allow\r\ncommon expressions to be saved and re-used instead of repeated\r\nverbatim each time. Wax also contains a few other functions that\r\nI found useful when working with expressions.\r\n\r\n```csharp\r\nusing System;\r\nusing System.Linq.Expressions;\r\nusing ExpressionKit.Unwrap;\r\n\r\nstatic class Example\r\n{\r\n  static Expression<Func<int, int>> Square = x => x * x;\r\n\r\n  static Expression<Func<int, int>> SquSquare = Wax.Unwrap<int, int>(\r\n    x => Square.Expand(Square.Expand(x)));\r\n\r\n  static Expression<Func<int, int>> Cube = Wax.Unwrap<int, int>(\r\n    x => SquSquare.Expand(x) / x);\r\n\r\n  static Expression<Func<int, int>> Foo = Wax.Unwrap<int, int>(\r\n    x => Cube.Expand(x + 1) * Square.Expand(x - 1));\r\n\r\n  static void Main()\r\n  {\r\n    var expressions = new[]\r\n    {\r\n      Square,\r\n      SquSquare,\r\n      Cube,\r\n      Foo\r\n    };\r\n\r\n    foreach (var expression in expressions)\r\n      Console.WriteLine(expression);\r\n  }\r\n}\r\n```\r\n\r\n```sh\r\nx => (x * x)\r\nx => ((x * x) * (x * x))\r\nx => (((x * x) * (x * x)) / x)\r\nx => (((((x + 1) * (x + 1)) * ((x + 1) * (x + 1))) / (x + 1)) * ((x - 1) * (x - 1)))\r\n```\r\n\r\nInstallation\r\n============\r\n\r\nTo install Wax, run\r\n\r\n```\r\nInstall-Package Wax\r\n```\r\n\r\nin your NuGet package manager console, or download the source and compile with\r\n\r\n```sh\r\n# Assuming Mono's C# compiler\r\nmcs -o+ -t:library -out:Wax.dll *.cs\r\n```\r\n\r\nThen, in your code,\r\n\r\n```csharp\r\nusing ExpressionKit.Unwrap;\r\n```\r\n\r\nThe Functions\r\n=============\r\n\r\nUnwrap\r\n------\r\n\r\nThis is the heart of Wax.\r\nIt's used to unwrap other expressions into their definitions for you,\r\nso that Linq-to-SQL (or perhaps other frameworks that expect simple\r\nexpressions) can digest them.\r\n\r\nThere are two variations of `Unwrap`: one for functions receiving a\r\nsingle argument, and another for functions receiving two arguments.\r\nIn practice, I haven't needed more than this, but I may extend these\r\nto the full length offered by `Func<T...>` in the future.\r\n\r\nExpressions are marked for unwrapping using `Expand`, which also\r\nhas two variants.\r\n\r\nExample:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing ExpressionKit.Unwrap;\r\n\r\nstatic class MyProgram\r\n{\r\n  static Expression<Func<MyModel, IQueryable<MyProperty>>>\r\n    ModelProperties = /* some complex selection */;\r\n    \r\n  static void Main()\r\n  {\r\n    var red = MyContext.MyModels\r\n      .Where(Wax.Unwrap<MyModel, bool>(m => ModelProperties\r\n        .Expand(m)\r\n        .Any(p => p.Color == Colors.Red)));\r\n  }\r\n}\r\n```\r\n\r\nOf course, having to explicitly state the type parameters\r\nfor `Unwrap` every time can be irritating, and it is\r\nimpossible when one of the type parameters refers to an anonymous type.\r\nWhich is why Wax also provides...\r\n\r\nUnwrappedWhere\r\n--------------\r\n\r\nThis function is just Linq's `Where` combined with `Unwrap`\r\nto give you the convenience of type inference.\r\nUsing `UnwrappedWhere`, our above example becomes:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\nusing ExpressionKit.Unwrap;\r\n\r\nstatic class MyProgram\r\n{\r\n  static Expression<Func<MyModel, IQueryable<MyProperty>>>\r\n    ModelProperties = /* some complex selection */;\r\n    \r\n  static void Main()\r\n  {\r\n    var red = MyContext.MyModels\r\n      .UnwrappedWhere(m => ModelProperties\r\n        .Expand(m)\r\n        .Any(p => p.Color == Colors.Red)));\r\n  }\r\n}\r\n```\r\n\r\nUnwrappedSelect\r\n---------------\r\n\r\nThis function is similar to `UnwrappedWhere`.\r\nYou can probably guess what it does.\r\n\r\nOr, And, Inverse\r\n----------------\r\n\r\nThese three functions provide basic boolean logic for working with expressions.\r\nTheir functionality doesn't extend far beyond what's offerred by `Expression`,\r\nbut they are provided as extension methods, which I find easier to read.\r\n\r\nAny, All\r\n--------\r\n\r\nThese two functions are just shorthand for combining lists of expressions with\r\n`Or` or `And`, respectively.\r\n\r\nExpand\r\n------\r\n\r\nThis function doesn't do much by itself; it's only used to flag\r\nwhich expressions to `Unwrap`. When actually evaluated, it will\r\nthrow an `InvalidOperationException`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}