{"name":"Wax","tagline":"A .NET library of useful functions for manipulating expression trees.","body":"Wax\r\n===\r\n\r\nWax grew out of my frustration with Linq-to-SQL's inability to handle `InvocationExpression`s,\r\nso its main purpose is to allow common expressions to be saved and re-used instead of repeated\r\nverbatim each time. Wax also contains a few other functions that I found useful when\r\nworking with expressions.\r\n\r\nThe Functions\r\n=============\r\n\r\nUnwrap\r\n------\r\n\r\nThis is the heart of Wax. It's used to unwrap other expressions into their definitions for you,\r\nso that Linq-to-SQL (or perhaps other frameworks that expect simple expressions) can digest them.\r\n\r\nThere are two variations of `Unwrap`: one for functions receiving a single argument,\r\nand another for functions receiving two arguments. In practice, I haven't needed more than this,\r\nbut I may extend these to the full length offered by `Func<T...>` in the future.\r\n\r\nExpressions are marked for unwrapping using `Expand`, which also has two variants.\r\n\r\nExample:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\n\r\nstatic class MyProgram\r\n{\r\n  static Expression<Func<MyModel, IQueryable<MyProperty>>>\r\n    ModelProperties = /* some complex selection */;\r\n    \r\n  static void Main()\r\n  {\r\n    var red = MyContext.MyModels.Where(Wax.Unwrap<MyModel, bool>(m => ModelProperties\r\n      .Expand(m)\r\n      .Any(p => p.Color == Colors.Red)));\r\n  }\r\n}\r\n```\r\n\r\nOf course, having to explicitly state the type parameters for `Unwrap` every time can be irritating, and\r\nit is impossible when one of the type parameters refers to an anonymous type.\r\nWhich is why Wax also provides...\r\n\r\nUnwrappedWhere\r\n--------------\r\n\r\nThis function is just Linq's `Where` combined with `Unwrap` to give you the convenience of type inference.\r\nUsing `UnwrappedWhere`, our above example becomes:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Linq;\r\nusing System.Linq.Expressions;\r\n\r\nstatic class MyProgram\r\n{\r\n  static Expression<Func<MyModel, IQueryable<MyProperty>>>\r\n    ModelProperties = /* some complex selection */;\r\n    \r\n  static void Main()\r\n  {\r\n    var red = MyContext.MyModels.UnwrappedWhere(m => ModelProperties\r\n      .Expand(m)\r\n      .Any(p => p.Color == Colors.Red)));\r\n  }\r\n}\r\n```\r\n\r\nUnwrappedSelect\r\n---------------\r\n\r\nThis function is similar to `UnwrappedWhere`. You can probably guess what it does.\r\n\r\nOr, And, Inverse\r\n----------------\r\n\r\nThese three functions provide basic boolean logic for working with expressions.\r\nTheir functionality doesn't extend far beyond what's offerred by `Expression`,\r\nbut they are provided as extension methods, which I find easier to read.\r\n\r\nAny, All\r\n--------\r\n\r\nThese two functions are just shorthand for combining lists of expressions with\r\n`Or` or `And`, respectively.\r\n\r\nExpand\r\n------\r\n\r\nThis function doesn't do much by itself; it's only used to flag which expressions to\r\n`Unwrap`. When actually evaluated, it will throw an `InvalidOperationException`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}