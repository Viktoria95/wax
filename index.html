<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Wax by mrhmouse</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Wax</h1>
        <p class="header">Designed to aid in the reuse of Expression trees.</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/mrhmouse/wax/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/mrhmouse/wax/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/mrhmouse/wax">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/mrhmouse">mrhmouse</a></p>


      </header>
      <section>
        <h1>
<a id="wax" class="anchor" href="#wax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wax</h1>

<p>Wax grew out of my frustration with Linq-to-SQL's inability to
handle <code>InvocationExpression</code>s, so its main purpose is to allow
common expressions to be saved and re-used instead of repeated
verbatim each time. Wax also contains a few other functions that
I found useful when working with expressions.</p>

<div class="highlight highlight-csharp"><pre><span class="pl-k">using</span> System;
<span class="pl-k">using</span> System.Linq.Expressions;
<span class="pl-k">using</span> ExpressionKit.Unwrap;

<span class="pl-s">static</span> <span class="pl-s">class</span> <span class="pl-en">Example</span>
{
  <span class="pl-s">static</span> Expression&lt;Func&lt;<span class="pl-st">int</span>, <span class="pl-st">int</span>&gt;&gt; Square = x =&gt; x * x;

  <span class="pl-s">static</span> Expression&lt;Func&lt;<span class="pl-st">int</span>, <span class="pl-st">int</span>&gt;&gt; SquSquare = Wax.Unwrap&lt;int, int&gt;(
    x =&gt; <span class="pl-en">Square.Expand</span>(Square.Expand(x)));

  <span class="pl-s">static</span> Expression&lt;Func&lt;<span class="pl-st">int</span>, <span class="pl-st">int</span>&gt;&gt; Cube = Wax.Unwrap&lt;int, int&gt;(
    x =&gt; <span class="pl-en">SquSquare.Expand</span>(x) / x);

  <span class="pl-s">static</span> Expression&lt;Func&lt;<span class="pl-st">int</span>, <span class="pl-st">int</span>&gt;&gt; Foo = Wax.Unwrap&lt;int, int&gt;(
    x =&gt; <span class="pl-en">Cube.Expand</span>(x + 1) * <span class="pl-en">Square.Expand</span>(x - 1));

  <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">Main</span>()
  {
    <span class="pl-k">var</span> expressions = <span class="pl-s">new</span>[]
    {
      Square,
      SquSquare,
      Cube,
      Foo
    };

    <span class="pl-k">foreach</span> (<span class="pl-k">var</span> expression <span class="pl-k">in</span> expressions)
      Console.WriteLine(expression);
  }
}</pre></div>

<div class="highlight highlight-sh"><pre>x =<span class="pl-k">&gt;</span> (x <span class="pl-k">*</span> x)
x =<span class="pl-k">&gt;</span> <span class="pl-s1"><span class="pl-pds">((</span>x <span class="pl-k">*</span> x) <span class="pl-k">*</span> (x <span class="pl-k">*</span> x<span class="pl-pds">))</span></span>
x =<span class="pl-k">&gt;</span> <span class="pl-s1"><span class="pl-pds">((</span>(x <span class="pl-k">*</span> x) <span class="pl-k">*</span> (x <span class="pl-k">*</span> x<span class="pl-pds">))</span></span> / x)
x =<span class="pl-k">&gt;</span> <span class="pl-s1"><span class="pl-pds">((</span>(((x <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">*</span> (x <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-pds">))</span></span> <span class="pl-k">*</span> <span class="pl-s1"><span class="pl-pds">((</span>x <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">*</span> (x <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-pds">))</span></span>) / (x + 1)) <span class="pl-k">*</span> <span class="pl-s1"><span class="pl-pds">((</span>x <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">*</span> (x <span class="pl-k">-</span> <span class="pl-c1">1</span><span class="pl-pds">))</span></span>)</pre></div>

<h1>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h1>

<p>To install Wax, run</p>

<pre><code>Install-Package Wax
</code></pre>

<p>in your NuGet package manager console, or download the source and compile with</p>

<div class="highlight highlight-sh"><pre><span class="pl-c"># Assuming Mono's C# compiler</span>
mcs -o+ -t:library -out:Wax.dll <span class="pl-k">*</span>.cs</pre></div>

<p>Then, in your code,</p>

<div class="highlight highlight-csharp"><pre><span class="pl-k">using</span> ExpressionKit.Unwrap;</pre></div>

<h1>
<a id="the-functions" class="anchor" href="#the-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Functions</h1>

<h2>
<a id="unwrap" class="anchor" href="#unwrap" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unwrap</h2>

<p>This is the heart of Wax.
It's used to unwrap other expressions into their definitions for you,
so that Linq-to-SQL (or perhaps other frameworks that expect simple
expressions) can digest them.</p>

<p>There are two variations of <code>Unwrap</code>: one for functions receiving a
single argument, and another for functions receiving two arguments.
In practice, I haven't needed more than this, but I may extend these
to the full length offered by <code>Func&lt;T...&gt;</code> in the future.</p>

<p>Expressions are marked for unwrapping using <code>Expand</code>, which also
has two variants.</p>

<p>Example:</p>

<div class="highlight highlight-csharp"><pre><span class="pl-k">using</span> System;
<span class="pl-k">using</span> System.Linq;
<span class="pl-k">using</span> System.Linq.Expressions;
<span class="pl-k">using</span> ExpressionKit.Unwrap;

<span class="pl-s">static</span> <span class="pl-s">class</span> <span class="pl-en">MyProgram</span>
{
  <span class="pl-s">static</span> Expression&lt;Func&lt;MyModel, IQueryable&lt;MyProperty&gt;&gt;&gt;
    ModelProperties = <span class="pl-c">/* some complex selection */</span>;

  <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">Main</span>()
  {
    <span class="pl-k">var</span> red = MyContext.MyModels
      .Where(Wax.Unwrap&lt;MyModel, <span class="pl-st">bool</span>&gt;(m =&gt; ModelProperties
        .Expand(m)
        .Any(p =&gt; p.Color == Colors.Red)));
  }
}</pre></div>

<p>Of course, having to explicitly state the type parameters
for <code>Unwrap</code> every time can be irritating, and it is
impossible when one of the type parameters refers to an anonymous type.
Which is why Wax also provides...</p>

<h2>
<a id="unwrappedwhere" class="anchor" href="#unwrappedwhere" aria-hidden="true"><span class="octicon octicon-link"></span></a>UnwrappedWhere</h2>

<p>This function is just Linq's <code>Where</code> combined with <code>Unwrap</code>
to give you the convenience of type inference.
Using <code>UnwrappedWhere</code>, our above example becomes:</p>

<div class="highlight highlight-csharp"><pre><span class="pl-k">using</span> System;
<span class="pl-k">using</span> System.Linq;
<span class="pl-k">using</span> System.Linq.Expressions;
<span class="pl-k">using</span> ExpressionKit.Unwrap;

<span class="pl-s">static</span> <span class="pl-s">class</span> <span class="pl-en">MyProgram</span>
{
  <span class="pl-s">static</span> Expression&lt;Func&lt;MyModel, IQueryable&lt;MyProperty&gt;&gt;&gt;
    ModelProperties = <span class="pl-c">/* some complex selection */</span>;

  <span class="pl-s">static</span> <span class="pl-st">void</span> <span class="pl-en">Main</span>()
  {
    <span class="pl-k">var</span> red = MyContext.MyModels
      .UnwrappedWhere(m =&gt; ModelProperties
        .Expand(m)
        .Any(p =&gt; p.Color == Colors.Red)));
  }
}</pre></div>

<h2>
<a id="unwrappedselect" class="anchor" href="#unwrappedselect" aria-hidden="true"><span class="octicon octicon-link"></span></a>UnwrappedSelect</h2>

<p>This function is similar to <code>UnwrappedWhere</code>.
You can probably guess what it does.</p>

<h2>
<a id="or-and-inverse" class="anchor" href="#or-and-inverse" aria-hidden="true"><span class="octicon octicon-link"></span></a>Or, And, Inverse</h2>

<p>These three functions provide basic boolean logic for working with expressions.
Their functionality doesn't extend far beyond what's offerred by <code>Expression</code>,
but they are provided as extension methods, which I find easier to read.</p>

<h2>
<a id="any-all" class="anchor" href="#any-all" aria-hidden="true"><span class="octicon octicon-link"></span></a>Any, All</h2>

<p>These two functions are just shorthand for combining lists of expressions with
<code>Or</code> or <code>And</code>, respectively.</p>

<h2>
<a id="expand" class="anchor" href="#expand" aria-hidden="true"><span class="octicon octicon-link"></span></a>Expand</h2>

<p>This function doesn't do much by itself; it's only used to flag
which expressions to <code>Unwrap</code>. When actually evaluated, it will
throw an <code>InvalidOperationException</code>.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
